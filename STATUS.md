# Кратко, что сделано (день 2)

- Подключение к удалённым БД через `.env`: Postgres, MongoDB, Redis, Qdrant, Neo4j (RabbitMQ пока не трогаем).
- Скрипт `scripts/check_connections.py` проверяет все сервисы (RabbitMQ сейчас не подключается, это нормально).
- Скрипт `scripts/mongo_show_db.py` показывает базы/коллекции в Mongo.
- API (FastAPI) поднято в `api/`:
  - Запуск: `./.venv/bin/uvicorn api.main:app --reload --port 8000`
  - Эндпойнты: `/health`, `/ping`, `POST /notes`, `GET /notes/{id}`, `GET /notes?q=...&limit=&offset=`.
  - Таблица в Postgres создаётся автоматически на старте как `notes_<student>` (имя студента берётся из `STUDENT_NAME` в нижнем регистре).
  - Дата в ответах теперь `datetime`, не строки (исправлено).

Сейчас работает:
- Подключения к Postgres/Mongo/Redis/Qdrant/Neo4j ок (см. последний запуск check_connections).
- CRUD по заметкам в Postgres работает после фикса схемы ответа.

Доступные функции (эндпойнты):
- GET /health — статус сервера, имя студента, хосты сервисов из .env.
- GET /ping — простая проверка «живости».
- POST /notes — создать заметку (title, content, tags?), пишет в Postgres, возвращает созданную запись.
- GET /notes/{id} — получить заметку по id из Postgres.
- GET /notes?q=...&limit=&offset= — список заметок, либо поиск по подстроке в title/content (ILIKE), с пагинацией.
- PUT /notes/{id} — обновить заметку (title/content/tags) в Postgres, пишет новую версию в Mongo.
- GET /notes/{id}/versions — версии заметки из Mongo (последние, по убыванию версии).
- POST /notes/{id}/restore — восстановить заметку из указанной версии (берёт снапшот из Mongo, пишет в Postgres, создаёт новую версию).
- GET /notes/popular?limit=10 — топ заметок по просмотрам (счётчики в Redis).
- GET /notes/{id}/similar?limit=5 — поиск похожих заметок в Qdrant (эмбеддинг-заглушка на sha256 текста).

Что дальше (предлагаемое):
- Добавить сохранение версий заметок в Mongo при создании/обновлении.
- Добавить Redis-кэш для `GET /notes/{id}`.
- Подготовить заглушку для RabbitMQ/worker или пропустить до появления сервиса.

Как работает API сейчас:
- `main.py` — входная точка FastAPI. При старте читает `.env`, создаёт таблицу в Postgres (если её нет), подключает маршруты и служебные ручки `/health` и `/ping`.
- `routes.py` — описывает HTTP-ручки `/notes`: создать, получить по id, список/поиск, обновить, показать версии, восстановить из версии. Делегирует операции в `db.py` и `mongo_versions.py`.
- `db.py` — общение с Postgres. Собирает имя базы и таблицы с суффиксом `STUDENT_NAME` (нижний регистр), создаёт таблицу с триггером на `updated_at` и GIN-индексом. Функции: `insert_note`, `fetch_note`, `search_notes`, `update_note`.
- `mongo_versions.py` — хранение версий в Mongo: `save_version`, `get_versions`, `get_version`, коллекция `note_versions_<student>`.
- `cache.py` — работа с Redis: кэш заметок (key `note:<id>`, TTL по умолчанию 120 c), счётчик популярности в sorted set (`popular_notes`).
- `qdrant_vectors.py` — работа с Qdrant: создаёт коллекцию `notes_vectors_<student>`, вычисляет эмбеддинг-заглушку (sha256 текста) и пишет/ищет точки.
- `schemas.py` — Pydantic-схемы. `NoteCreate` валидирует вход (title, content, tags). `NoteUpdate` для изменений. `NoteRestore` для восстановления из версии. `NoteOut` описывает ответ (включая `datetime` для created_at/updated_at).

Как работает кэш и топ в Redis:
- При `GET /notes/{id}` сначала читаем кэш (`note:<id>`). Если нет — берём из Postgres и кладём в кэш (TTL 120 секунд).
- На каждом чтении увеличиваем счётчик популярности в sorted set `popular_notes` (`zincrby`).
- Эндпойнт `GET /notes/popular` читает топ из Redis и пытается вернуть сами заметки (из кэша или БД), вместе с числом просмотров (`score`).
- Переменные окружения, которые влияют: `REDIS_HOST/PORT/DB`, `REDIS_NOTE_TTL` (секунды, по умолчанию 120), `REDIS_POPULAR_KEY` (по умолчанию `popular_notes`).

Как работает похожие (Qdrant):
- Коллекция `notes_vectors_<student>` создаётся автоматически при первом upsert.
- Эмбеддинг — простая заглушка: sha256 от текста заметки (title+content+tags) разворачивается в вектор длиной 64; расстояние — косинус.
- При создании/обновлении/восстановлении заметки точка пишется в Qdrant (`upsert_note_vector`).
- `GET /notes/{id}/similar?limit=5` — ищет похожие по вектору текущей заметки, возвращает note_id, title, tags, score. Чтобы был результат, нужно чтобы хотя бы 2 заметки попали в Qdrant (через создание/обновление).
- Можно использовать существующую коллекцию от преподавателя: задайте `QDRANT_COLLECTION=<имя>` в `.env`. Если коллекции нет — будет ошибка, новая не создастся. Если переменная не задана — создаётся/используется `notes_vectors_<student>`.
- Размер вектора: можно задать `QDRANT_VECTOR_SIZE` в `.env`. Если не задан, берём размер существующей коллекции; если и её нет — используем 64 по умолчанию. Если подключаетесь к готовой коллекции, обязательно укажите подходящий размер или он будет считан из её настроек. Ошибка `expected dim: X, got Y` значит, что текущий размер не совпал с размером коллекции.

Обновление эмбеддингов:
- Теперь эмбеддинг — "хэш-эмбеддинг" по токенам (hashing trick): токены → md5 → индекс = hash % size, знак по биту, нормализация L2. Размер задаётся `QDRANT_VECTOR_SIZE` (дефолт 128).
- Если хочешь другую размерность/новую коллекцию: укажи новое имя в `QDRANT_COLLECTION` (чтобы не конфликтовать со старой) и `QDRANT_VECTOR_SIZE` (например, 128). Коллекция создастся автоматически при первом upsert.

Демо для похожих:
1) Создай 2–3 заметки с разными/похожими тегами/текстом (`POST /notes`), чтобы они записались в Qdrant.
2) Вызови `GET /notes/{id}/similar?limit=5` для одной из них.
3) В ответе будут близкие заметки (включая саму себя; можешь отфильтровать client-side, если нужно).

Как показать (демо):
1) Запусти API: `./.venv/bin/uvicorn api.main:app --reload --port 8000`.
2) Создай 2–3 заметки через `POST /notes`.
3) Сделай несколько запросов `GET /notes/{id}` к разным заметкам (чтобы накрутить просмотры). Повтори одни и те же id несколько раз.
4) Вызови `GET /notes/popular?limit=5` — увидишь список заметок с `score` (кол-во просмотров). Если кэш истёк, заметки подтянутся из БД, но счётчики останутся в Redis.
